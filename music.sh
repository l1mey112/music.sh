#!/usr/bin/env bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
readonly SCRIPT_DIR

readonly SECONDS_MINUTE=60
readonly SECONDS_HOUR=$((60 * SECONDS_MINUTE))

# PARAMETERS {{

readonly JOBS=${JOBS:-4}
readonly DATA_DIR=${DATA_DIR:-"$SCRIPT_DIR/music"}

# TODO: add a fuzz factor as well
readonly RECHECK_INTERVAL=${RECHECK_INTERVAL:-$((1 * SECONDS_HOUR))}

# }}

source "$SCRIPT_DIR/lib/prelude.sh"
source "$SCRIPT_DIR/lib/path.sh"

# playlist_extract_canonical
#
# This is needed for various reasons. When you go to the Releases tab of
# some artist on their YouTube channel, for example
#  
#     https://www.youtube.com/@lapix_official/releases
#
# it will contain playlists with prefix OLAK5uy, these are albums.
# (see ^[archiveteam] for a proper taxonomy)
#
# Take this album ^[1] for example. Most of the songs there are YouTube
# Music "square videos" which are autogenerated and contain the metadata
# in the description in a predictable format that yt-dlp scrapes.
#
# There are some videos in here, for example "Concept Of Reality feat. Renko"
# which aren't autogenerated and hence doesn't have correct metadata in the
# description. The reason why is because this isn't the right playlist. If
# you take the playlist url and replace "www." with "music." you will be
# redirected to a playlist with an ID with a different playlist.
#
# This playlist contains videos that are only autogenerated, and hence have
# the right description. See ^[2] on the yt-dlp Discord for the full convo.
#
# [^archiveteam]: https://wiki.archiveteam.org/index.php/YouTube/Technical_details
# [^1]: https://www.youtube.com/playlist?list=OLAK5uy_mWid7P-a7WtzrJmkmoTewY6Vy2R23jkrA
# [^2]: https://discord.com/channels/807245652072857610/807245652072857613/1467002380301373746
#
# TLDR: use this to get the right playlist.
#
playlist_extract_canonical() {
	local URL="$1"
	local useragent="Mozilla/5.0 (X11; Linux x86_64; rv:147.0) Gecko/20100101 Firefox/147.0"

	local playlist
	playlist=$(echo "$URL" | sed -E 's/(www\.)?youtube\.com/music.youtube.com/')

	# <link rel="canonical" href="https://music.youtube.com/playlist?list=NEW_URL">
	local extracted
	extracted=$(curl -sL "$playlist" -A "$useragent" | grep -oP '<link rel="canonical" href="\K[^"]+')

	if [[ -z "$extracted" ]] || [[ "$extracted" == "undefined" ]] || [[ "$extracted" != http* ]]; then
		log "playlist_extract_canonical: returned empty, you might be using playlist lists wrong"
		log "playlist_extract_canonical: url: $URL"
		echo "$URL"
	else
		# echo "$extracted" | sed 's/music\.//'
		echo "${extracted/music./}"
	fi
}

# does not call path_safe on the name, caller's responsibility
playlist_extract_title() {
	local URL="$1"

	local output
	output=$(yt-dlp "$URL" --flat-playlist --dump-single-json | jq -r .title)

	local ytdlp_status=$?
	[[ $ytdlp_status -eq 0 ]] || assert "  -> yt-dlp failed for this seed file (exit code: $ytdlp_status)"

	echo "$output"
}

handle_seed_playlist_list() {
	readonly ARTIST="$1"
	readonly PLAYLIST_LIST_URL="$2"

	local output
	output=$(yt-dlp --flat-playlist --print "%(webpage_url)s;%(title)s" "$PLAYLIST_LIST_URL" 2>/dev/null)

	local ytdlp_status=$?
	[[ $ytdlp_status -eq 0 ]] || assert "  -> yt-dlp failed for this seed file (exit code: $ytdlp_status)"

	if [[ -z "$output" ]]; then
		log "  -> no playlists discovered"
		return
	fi

	local playlist_data
	mapfile -t playlist_data <<< "$output"
	for line in "${playlist_data[@]}"; do
		local playlist_url playlist_title
		IFS=';' read -r playlist_url playlist_title <<< "$line"

		playlist_url=$(playlist_extract_canonical "$playlist_url")

		# (kind, artist, playlist, title)
		echo "immutable;$ARTIST;$playlist_url;$playlist_title"
	done

	log "  -> got ${#playlist_data[@]} playlists"
}

# accepts a tuple of the form "kind;artist;playlist;title"
handle_seed_playlist() {
	# kind;artist;playlist;title
	local kind artist playlist title
	IFS=';' read -r kind artist playlist title <<< "$1"

	log "Writing: $artist - $title ($kind)"

	local album_filename
	local artist_path

	album_filename="$(path_safe "$title").rec"
	artist_path="$DATA_DIR/$(path_safe "$artist")"
	mkdir -p "$artist_path"

	cat <<EOF > "$artist_path/$album_filename"
%rec: AlbumDescriptor _Schema/AlbumDescriptor.rec

# automatically generated, will be overwritten
AlbumArtist: $artist
AlbumTitle: $title
Source: $playlist
Created: $(LC_ALL=C TZ=UTC0 date)
Metadata: $kind

%rec: YouTubeTrack _Schema/YouTubeTrack.rec
EOF

	local video_data
	mapfile -t video_data < <(yt-dlp \
		--match-filter "original_url!*=/shorts/ & url!*=/shorts/" \
		--flat-playlist --print "%(id)s;%(title)s" "$playlist" 2>/dev/null)

	for line in "${video_data[@]}"; do
		local video_id video_title
		IFS=';' read -r video_id video_title <<< "$line"

		cat <<EOF >> "$artist_path/$album_filename"

Title: $video_title
YouTubeId: $video_id
EOF
	done

	log "  -> wrote ${#video_data[@]}"
}

handle_seed() {
	readonly SEED="$1"
	log "seed file $SEED"

	# artist;playlist;title
	local urls
	local artist
	declare -a urls

	local current_epoch
	current_epoch=$(date +'%s')

	local amount=0
	while IFS= read -r line || [[ -n "$line" ]]; do
		if [[ -z "$line" ]]; then
			artist=""
			continue
		elif [[ "$line" == Artist:* ]]; then
			artist="${line#Artist: }"
			continue
		fi

		[[ -n $artist ]] || assert "seed file is malformed: Artist in the wrong order, must be first"

		if [[ "$line" == PlaylistRefresh:* ]] || [[ "$line" == PlaylistUploads:* ]]; then
			local line_kind playlist
			IFS=": " read -r line_kind playlist <<< "$line"
			
			log "(seed \"$artist\") $playlist"

			local title
			title=$(playlist_extract_title "$playlist")

			# add prefix to upload playlists, otherwise treat like a refresh
			if [[ "$line_kind" == "PlaylistUploads" ]]; then
				title="Uploads - $title"
			fi

			# (artist, playlist, title)
			urls=( "${urls[@]}" "mutable;$artist;$playlist;$title" )
		fi

		if [[ "$line" == Playlists:* ]]; then
			playlist_list="${line#Playlists: }"
			log "(seed list \"$artist\") $playlist_list"
		
			output=$(handle_seed_playlist_list "$artist" "$playlist_list")
			mapfile -t output_list <<< "$output"
			urls=( "${urls[@]}" "${output_list[@]}" )
		fi

		#((amount++)) - with `set -e` this entire thing dies as amount=0
		amount=$((amount + 1))
	done < <(recsel -e "Epoch < $current_epoch - $RECHECK_INTERVAL" -p Artist,Playlist,PlaylistRefresh,PlaylistUploads "$SEED")

	for tuple in "${urls[@]}"; do
		handle_seed_playlist "$tuple"
	done

	if [[ $amount -gt 0 ]]; then
		log "updated $amount entries (new epoch: $current_epoch)"

		# mark that we made changes
		recset -e "Epoch < $current_epoch - $RECHECK_INTERVAL" \
			-f Epoch -S "$current_epoch" \
			"$SEED"
	fi
}

# previously music.sh downloaded by youtube id, this goes by playlist now.
# yt-dlp can do more of the heavy lifting, and this script gets simpler

handle_seed "$DATA_DIR/Seed.rec"
