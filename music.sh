#!/usr/bin/env bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
readonly SCRIPT_DIR

# NOTE: do not use readonly in functions, these create global variables
readonly SECONDS_MINUTE=60
readonly SECONDS_HOUR=$((60 * SECONDS_MINUTE))

# PARAMETERS {{

readonly JOBS=${JOBS:-4}
readonly DATA_DIR=${DATA_DIR:-"$SCRIPT_DIR/music"}

# TODO: add a fuzz factor as well
readonly RECHECK_INTERVAL=${RECHECK_INTERVAL:-$((1 * SECONDS_HOUR))}

# }}

source "$SCRIPT_DIR/lib/prelude.sh"
source "$SCRIPT_DIR/lib/path.sh"

# TODO: switch to using \x1f as a separator instead of ; where it matters
readonly DLM=$'\x1f'

# playlist_extract_canonical
#
# This is needed for various reasons. When you go to the Releases tab of
# some artist on their YouTube channel, for example
#  
#     https://www.youtube.com/@lapix_official/releases
#
# it will contain playlists with prefix OLAK5uy, these are albums.
# (see ^[archiveteam] for a proper taxonomy)
#
# Take this album ^[1] for example. Most of the songs there are YouTube
# Music "square videos" which are autogenerated and contain the metadata
# in the description in a predictable format that yt-dlp scrapes.
#
# There are some videos in here, for example "Concept Of Reality feat. Renko"
# which aren't autogenerated and hence doesn't have correct metadata in the
# description. The reason why is because this isn't the right playlist. If
# you take the playlist url and replace "www." with "music." you will be
# redirected to a playlist with an ID with a different playlist.
#
# This playlist contains videos that are only autogenerated, and hence have
# the right description. See ^[2] on the yt-dlp Discord for the full convo.
#
# [^archiveteam]: https://wiki.archiveteam.org/index.php/YouTube/Technical_details
# [^1]: https://www.youtube.com/playlist?list=OLAK5uy_mWid7P-a7WtzrJmkmoTewY6Vy2R23jkrA
# [^2]: https://discord.com/channels/807245652072857610/807245652072857613/1467002380301373746
#
# TLDR: use this to get the right playlist.
#
playlist_extract_canonical() {
	local -r URL="$1"
	local -r useragent="Mozilla/5.0 (X11; Linux x86_64; rv:147.0) Gecko/20100101 Firefox/147.0"

	local playlist
	playlist=$(echo "$URL" | sed -E 's/(www\.)?youtube\.com/music.youtube.com/')

	# <link rel="canonical" href="https://music.youtube.com/playlist?list=NEW_URL">
	local extracted
	extracted=$(curl -sL "$playlist" -A "$useragent" | grep -oP '<link rel="canonical" href="\K[^"]+')

	if [[ -z "$extracted" ]] || [[ "$extracted" == "undefined" ]] || [[ "$extracted" != http* ]]; then
		log "playlist_extract_canonical: returned empty, you might be using playlist lists wrong"
		log "playlist_extract_canonical: url: $URL"
		echo "$URL"
	else
		# echo "$extracted" | sed 's/music\.//'
		echo "${extracted/music./}"
	fi
}

# does not call path_safe on the name, caller's responsibility
playlist_extract_title() {
	local -r URL="$1"

	local output
	output=$(yt-dlp "$URL" --flat-playlist --dump-single-json | jq -r .title)

	local ytdlp_status=$?
	[[ $ytdlp_status -eq 0 ]] || assert_fail "  -> yt-dlp failed for this seed file (exit code: $ytdlp_status)"

	echo "$output"
}

# TODO: eventually handle local files (that also respect the mutability, so these need to be handled)
# (mutability, albumtitle, albumartist, trackindex, title, youtubeid)
declare -a collected_tracks_list=()

# this is written in pure bash to avoid subshells where performance drops off
# a cliff. that means `recsel` is not used here
#
# this parser does not care about multiline continuations. this is expressed
# inside the schema anyway, but could be an issue if someone were to use %doc
parse_recfile_album() {
	local file="$1"

	local lines
	readarray -t lines < "$file"

	declare -A current_rec=()
	declare -A album_cache=()

	# AlbumDescriptor or Track
	local mode=""
	local track_idx=0

	try_commit_record() {
		[[ ${#current_rec[@]} -eq 0 ]] && return

		if [[ "$mode" == "AlbumDescriptor" ]]; then
			# cache the album data for next tracks
			local k
			for k in "${!current_rec[@]}"; do
				album_cache["$k"]="${current_rec[$k]}"
			done
		
		elif [[ "$mode" == "Track" ]]; then
			if [[ -z "${album_cache[AlbumTitle]}" ]]; then
				assert_fail "parse_recfile_album: Track found before AlbumDescriptor in $file"
			fi

			track_idx=$((track_idx + 1))
			
			local serialised
			# (mutability, albumtitle, albumartist, trackindex, title, youtubeid)
			printf -v serialised "%s${DLM}%s${DLM}%s${DLM}%s${DLM}%s${DLM}%s" \
				"${album_cache[Metadata]}" \
				"${album_cache[AlbumTitle]}" \
				"${album_cache[AlbumArtist]}" \
				"$track_idx" \
				"${current_rec[Title]}" \
				"${current_rec[YouTubeId]}"

			collected_tracks_list+=("$serialised")
		else
			log "parse_recfile_album: WARN found erroneous record of type $mode in $file"
		fi

		current_rec=()
	}

	local line
	for line in "${lines[@]}"; do

		if [[ -z "$line" ]]; then
			try_commit_record
			continue
		fi

		if [[ "${line:0:1}" == "#" ]]; then 
			continue
		fi

		if [[ "${line:0:5}" == "%rec:" ]]; then
			# %rec: TypeName _Schema/TypeName.rec
			local remainder="${line#%rec: }"
			mode="${remainder%% *}"
			continue
		fi

		if [[ "$line" == *:* ]]; then
			local key="${line%%:*}"
			local val="${line#*:}"
			
			# trim leading space
			val="${val# }"
			current_rec["$key"]="$val"
		fi
	done
	try_commit_record

	unset current_rec album_cache
}

collect_tracks() {
	# for every file inside $DATA_DIR that contains an AlbumDescriptor visit
	# that file and handle the Tracks
	local pattern="%rec: AlbumDescriptor _Schema/AlbumDescriptor.rec"
	local file_path

	while IFS= read -r -d '' file_path; do
		parse_recfile_album "$file_path"
	done < <(find "$DATA_DIR" -type f -exec grep -lZ -F "$pattern" {} +)
}

handle_seed_playlist_list() {
	local -r ARTIST="$1"
	local -r PLAYLIST_LIST_URL="$2"

	log "  -> extracting the list, please be patient"

	local output
	output=$(yt-dlp --flat-playlist --print "%(webpage_url)s;%(title)s" "$PLAYLIST_LIST_URL" 2>/dev/null)

	local ytdlp_status=$?
	[[ $ytdlp_status -eq 0 ]] || assert_fail "  -> yt-dlp failed for this seed file (exit code: $ytdlp_status)"

	if [[ -z "$output" ]]; then
		log "  -> no playlists discovered"
		return
	fi

	local playlist_data line
	mapfile -t playlist_data <<< "$output"
	for line in "${playlist_data[@]}"; do
		local playlist_url playlist_title
		IFS=';' read -r playlist_url playlist_title <<< "$line"

		playlist_url=$(playlist_extract_canonical "$playlist_url")

		# (kind, artist, playlist, title)
		echo "immutable;$ARTIST;$playlist_url;$playlist_title"
	done

	log "  -> got ${#playlist_data[@]} playlists"
}

# accepts a tuple of the form "kind;artist;playlist;title"
handle_seed_playlist() {
	# kind;artist;playlist;title
	local kind artist playlist title
	IFS=';' read -r kind artist playlist title <<< "$1"

	log "$artist - $title ($kind)"

	local album_filename
	local artist_path

	album_filename="$(path_safe "$title").rec"
	artist_path="$DATA_DIR/$(path_safe "$artist")"
	mkdir -p "$artist_path"

	local tmp_dir file_path tmp_file_path
	tmp_dir=$(mktemp -d)
	# need to remove the trap when coming out, for some reason
	trap 'rm -rf -- "$tmp_dir"; trap - RETURN' RETURN

	# TODO: at some point, it might be preferrable to actually search through
	#       all the files in the "$artist_path" directory to find a file with
	#       a matching Source, then do the update.
	#
	#       until then if you change the name of the file and reseed, it will
	#       duplicate the album. probably not what you want, but in the current
	#       state you do get to change the name anyway.
	#
	#       if the name of the playlist changes, this also will happen.

	# we want to atomically edit this playlist nicely
	tmp_file_path="$tmp_dir/album.rec"
	file_path="$artist_path/$album_filename"
	local created=false

	# if the file doesn't exist, create it
	if ! [[ -e "$file_path" ]]; then
		created=true
		cat <<EOF > "$tmp_file_path"
%rec: AlbumDescriptor _Schema/AlbumDescriptor.rec

AlbumArtist: $artist
AlbumTitle: $title
Source: $playlist
Created: $(LC_ALL=C TZ=UTC0 date)
Metadata: $kind

# automatically generated, do not edit tracklist below

%rec: Track _Schema/Track.rec
EOF
	else
		# --force this because we are deleting all the entries (dangerous)
		cp "$file_path" "$tmp_file_path"
		recdel -t Track --force "$tmp_file_path"
	fi

	local video_data line
	mapfile -t video_data < <(yt-dlp \
		--match-filter "original_url!*=/shorts/ & url!*=/shorts/" \
		--flat-playlist --print "%(id)s;%(title)s" "$playlist" 2>/dev/null)

	for line in "${video_data[@]}"; do
		local video_id video_title
		IFS=';' read -r video_id video_title <<< "$line"

		# we want to --force this because we can't access the schema anyway
		recins -t Track --force "$tmp_file_path" \
			-f Title -v "$video_title" \
			-f YouTubeId -v "$video_id"
	done

	# atomic please
	mv "$tmp_file_path" "$file_path"
	if $created; then
		log "  -> wrote ${#video_data[@]}"
		log "  -> created $album_filename"
	else
		log "  -> wrote ${#video_data[@]}"
		log "  -> edited $album_filename"
	fi
}

handle_seed() {
	local -r SEED="$DATA_DIR/Seed.rec"
	log "seed file $SEED"

	# artist;playlist;title
	local urls
	local artist
	declare -a urls

	local current_epoch
	current_epoch=$(date +'%s')

	local amount=0
	while IFS= read -r line || [[ -n "$line" ]]; do
		if [[ -z "$line" ]]; then
			artist=""
			continue
		elif [[ "$line" == Artist:* ]]; then
			artist="${line#Artist: }"
			continue
		fi

		[[ -n $artist ]] || assert_fail "seed file is malformed: Artist in the wrong order, must be first"

		if [[ "$line" == PlaylistRefresh:* ]] || [[ "$line" == PlaylistUploads:* ]]; then
			local line_kind playlist
			IFS=": " read -r line_kind playlist <<< "$line"
			
			log "(seed \"$artist\") $playlist"

			local title
			title=$(playlist_extract_title "$playlist")

			# add prefix to upload playlists, otherwise treat like a refresh
			if [[ "$line_kind" == "PlaylistUploads" ]]; then
				title="Uploads - $title"
			fi

			# (artist, playlist, title)
			urls=( "${urls[@]}" "mutable;$artist;$playlist;$title" )
		fi

		if [[ "$line" == Playlists:* ]]; then
			playlist_list="${line#Playlists: }"
			log "(seed list \"$artist\") $playlist_list"
		
			output=$(handle_seed_playlist_list "$artist" "$playlist_list")
			mapfile -t output_list <<< "$output"
			urls=( "${urls[@]}" "${output_list[@]}" )
		fi

		#((amount++)) - with `set -e` this entire thing dies as amount=0
		amount=$((amount + 1))
	done < <(recsel -e "Epoch < $current_epoch - $RECHECK_INTERVAL" -p Artist,Playlists,PlaylistRefresh,PlaylistUploads "$SEED")

	local tuple
	for tuple in "${urls[@]}"; do
		handle_seed_playlist "$tuple"
	done

	if [[ $amount -gt 0 ]]; then
		log "updated $amount entries (new epoch: $current_epoch)"

		# mark that we made changes
		recset -e "Epoch < $current_epoch - $RECHECK_INTERVAL" \
			-f Epoch -S "$current_epoch" \
			"$SEED"
	fi
}

handle_seed
collect_tracks # writes to collected_tracks_list (global)

log "${#collected_tracks_list[@]} collected tracks"

#for line in "${collected_tracks_list[@]}"; do
#	IFS=$DLM read -r mutability albumtitle albumartist trackindex title youtubeid <<< "$line"
#	echo $mutability $albumtitle $albumartist $trackindex $title $youtubeid
#done
