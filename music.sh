#!/usr/bin/env bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
readonly SCRIPT_DIR

# NOTE: do not use readonly in functions, these create global variables
readonly SECONDS_MINUTE=60
readonly SECONDS_HOUR=$((60 * SECONDS_MINUTE))

# PARAMETERS {{

readonly JOBS=${JOBS:-4}
DATA_DIR=${DATA_DIR:-"$SCRIPT_DIR/music"}
DATA_DIR="${DATA_DIR%/}"
readonly DATA_DIR

# TODO: add a fuzz factor as well
readonly RECHECK_INTERVAL=${RECHECK_INTERVAL:-$((48 * SECONDS_HOUR))}

# }}

source "$SCRIPT_DIR/lib/prelude.sh"
source "$SCRIPT_DIR/lib/path.sh"

# TODO: switch to using \x1f as a separator instead of ; where it matters
readonly DLM=$'\x1f'

# playlist_extract_canonical
#
# This is needed for various reasons. When you go to the Releases tab of
# some artist on their YouTube channel, for example
#  
#     https://www.youtube.com/@lapix_official/releases
#
# it will contain playlists with prefix OLAK5uy, these are albums.
# (see ^[archiveteam] for a proper taxonomy)
#
# Take this album ^[1] for example. Most of the songs there are YouTube
# Music "square videos" which are autogenerated and contain the metadata
# in the description in a predictable format that yt-dlp scrapes.
#
# There are some videos in here, for example "Concept Of Reality feat. Renko"
# which aren't autogenerated and hence doesn't have correct metadata in the
# description. The reason why is because this isn't the right playlist. If
# you take the playlist url and replace "www." with "music." you will be
# redirected to a playlist with an ID with a different playlist.
#
# This playlist contains videos that are only autogenerated, and hence have
# the right description. See ^[2] on the yt-dlp Discord for the full convo.
#
# [^archiveteam]: https://wiki.archiveteam.org/index.php/YouTube/Technical_details
# [^1]: https://www.youtube.com/playlist?list=OLAK5uy_mWid7P-a7WtzrJmkmoTewY6Vy2R23jkrA
# [^2]: https://discord.com/channels/807245652072857610/807245652072857613/1467002380301373746
#
# TLDR: use this to get the right playlist.
#
playlist_extract_canonical() {
	local -r URL="$1"
	local -r useragent="Mozilla/5.0 (X11; Linux x86_64; rv:147.0) Gecko/20100101 Firefox/147.0"

	local playlist
	playlist=$(echo "$URL" | sed -E 's/(www\.)?youtube\.com/music.youtube.com/')

	# <link rel="canonical" href="https://music.youtube.com/playlist?list=NEW_URL">
	local extracted
	extracted=$(curl -sL "$playlist" -A "$useragent" | grep -oP '<link rel="canonical" href="\K[^"]+')

	if [[ -z "$extracted" ]] || [[ "$extracted" == "undefined" ]] || [[ "$extracted" != http* ]]; then
		log "playlist_extract_canonical: returned empty, you might be using playlist lists wrong"
		log "playlist_extract_canonical: url: $URL"
		echo "$URL"
	else
		# echo "$extracted" | sed 's/music\.//'
		echo "${extracted/music./}"
	fi
}

# does not call path_safe on the name, caller's responsibility
playlist_extract_title() {
	local -r URL="$1"

	local output
	output=$(yt-dlp "$URL" --flat-playlist --dump-single-json | jq -r .title)

	local ytdlp_status=$?
	[[ $ytdlp_status -eq 0 ]] || assert_fail "  -> yt-dlp failed for this seed file (exit code: $ytdlp_status)"

	echo "$output"
}

# TODO: eventually handle local files (that also respect the mutability, so these need to be handled)
# (mutability, albumtitle, albumartist, trackindex, title, youtubeid)
declare -a collected_tracks_list=()

# this is written in pure bash to avoid subshells where performance drops off
# a cliff. that means `recsel` or other normalisation is not used here
#
# this parser does not care about multiline continuations. this is expressed
# inside the schema anyway, but could be an issue if someone were to use %doc
#
# TODO: eventually when things get slow (probably never), you might want to
#       use parallel
parse_recfile_album() {
	local file="$1"

	local lines
	readarray -t lines < "$file"

	declare -A current_rec=()
	declare -A album_cache=()

	# AlbumDescriptor or Track
	local mode=""
	local track_idx=0

	try_commit_record() {
		[[ ${#current_rec[@]} -eq 0 ]] && return

		if [[ "$mode" == "AlbumDescriptor" ]]; then
			# cache the album data for next tracks
			local k
			for k in "${!current_rec[@]}"; do
				album_cache["$k"]="${current_rec[$k]}"
			done
		
		elif [[ "$mode" == "Track" ]]; then
			if [[ -z "${album_cache[AlbumTitle]}" ]]; then
				assert_fail "parse_recfile_album: Track found before AlbumDescriptor in $file"
			fi

			track_idx=$((track_idx + 1))
			
			local serialised
			# (mutability, albumtitle, albumartist, trackindex, title, youtubeid)
			printf -v serialised "%s${DLM}%s${DLM}%s${DLM}%s${DLM}%s${DLM}%s" \
				"${album_cache[Metadata]}" \
				"${album_cache[AlbumTitle]}" \
				"${album_cache[AlbumArtist]}" \
				"$track_idx" \
				"${current_rec[Title]}" \
				"${current_rec[YouTubeId]}"

			collected_tracks_list+=("$serialised")
		else
			log "parse_recfile_album: WARN found erroneous record of type $mode in $file"
		fi

		current_rec=()
	}

	local line
	for line in "${lines[@]}"; do

		if [[ -z "$line" ]]; then
			try_commit_record
			continue
		fi

		if [[ "${line:0:1}" == "#" ]]; then 
			continue
		fi

		if [[ "${line:0:5}" == "%rec:" ]]; then
			# %rec: TypeName _Schema/TypeName.rec
			local remainder="${line#%rec: }"
			mode="${remainder%% *}"
			continue
		fi

		if [[ "$line" == *:* ]]; then
			local key="${line%%:*}"
			local val="${line#*:}"
			
			# trim leading space
			val="${val# }"
			current_rec["$key"]="$val"
		fi
	done
	try_commit_record

	unset current_rec album_cache
}

collect_tracks() {
	# for every file inside $DATA_DIR that contains an AlbumDescriptor visit
	# that file and handle the Tracks
	local file_path

	while IFS= read -r -d '' file_path; do
		parse_recfile_album "$file_path"
	done < <(rg -uu -l0F "%rec: AlbumDescriptor _Schema/AlbumDescriptor.rec" "$DATA_DIR" -g '!/_*')
}

handle_seed_playlist_list() {
	local -r ARTIST="$1"
	local -r PLAYLIST_LIST_URL="$2"

	log "  -> extracting the list, please be patient"

	local output
	output=$(yt-dlp --flat-playlist --print "%(webpage_url)s;%(title)s" "$PLAYLIST_LIST_URL" 2>/dev/null)

	local ytdlp_status=$?
	[[ $ytdlp_status -eq 0 ]] || assert_fail "  -> yt-dlp failed for this seed file (exit code: $ytdlp_status)"

	if [[ -z "$output" ]]; then
		log "  -> no playlists discovered"
		return
	fi

	local playlist_data line
	mapfile -t playlist_data <<< "$output"
	for line in "${playlist_data[@]}"; do
		local playlist_url playlist_title
		IFS=';' read -r playlist_url playlist_title <<< "$line"

		playlist_url=$(playlist_extract_canonical "$playlist_url")

		# (kind, artist, playlist, title)
		echo "immutable;$ARTIST;$playlist_url;$playlist_title"
	done

	log "  -> got ${#playlist_data[@]} playlists"
}

# accepts a tuple of the form "kind;artist;playlist;title"
handle_seed_playlist() {
	# kind;artist;playlist;title
	local kind artist playlist title
	IFS=';' read -r kind artist playlist title <<< "$1"

	log "$artist - $title ($kind)"

	local album_filename
	local artist_path

	album_filename="$(path_safe "$title").rec"
	artist_path="$DATA_DIR/$(path_safe "$artist")"
	mkdir -p "$artist_path"

	# TODO: at some point, it might be preferrable to actually search through
	#       all the files in the "$artist_path" directory to find a file with
	#       a matching Source, then do the update.
	#
	#       until then if you change the name of the file and reseed, it will
	#       duplicate the album. probably not what you want, but in the current
	#       state you do get to change the name anyway.
	#
	#       if the name of the playlist changes, this also will happen.

	# check if the album with the same "Source:" exists already.
	#
	# for example, VOLTA and RewindFlash share some of the same releases, but
	# RewindFlash is a label and we want as much music under the label as we can
	if rg -uuqF "Source: $playlist" "$DATA_DIR" -g '!/_*' -g "!${artist_path#"$DATA_DIR"/}"; then
		log "  -> album $title by $artist with Source already exists, ignoring"
		return
	fi

	local tmp_dir file_path tmp_file_path
	tmp_dir=$(mktemp -d)
	# need to remove the trap when coming out, for some reason
	trap 'rm -rf -- "$tmp_dir"; trap - RETURN' RETURN

	# we want to atomically edit this playlist nicely
	tmp_file_path="$tmp_dir/album.rec"
	file_path="$artist_path/$album_filename"
	local created=false

	# if the file doesn't exist, create it
	if ! [[ -e "$file_path" ]]; then
		created=true
		cat <<EOF > "$tmp_file_path"
%rec: AlbumDescriptor _Schema/AlbumDescriptor.rec

AlbumArtist: $artist
AlbumTitle: $title
Source: $playlist
Created: $(LC_ALL=C TZ=UTC0 date)
Metadata: $kind

# automatically generated, do not edit tracklist below

%rec: Track _Schema/Track.rec
EOF
	else
		# --force this because we are deleting all the entries (dangerous)
		cp "$file_path" "$tmp_file_path"
		recdel -t Track --force "$tmp_file_path"
	fi

	local video_data line
	mapfile -t video_data < <(yt-dlp \
		--match-filter "original_url!*=/shorts/ & url!*=/shorts/" \
		--flat-playlist --print "%(id)s;%(title)s" "$playlist" 2>/dev/null)

	for line in "${video_data[@]}"; do
		local video_id video_title
		IFS=';' read -r video_id video_title <<< "$line"

		# we want to --force this because we can't access the schema anyway
		recins -t Track --force "$tmp_file_path" \
			-f Title -v "$video_title" \
			-f YouTubeId -v "$video_id"
	done

	# atomic please
	mv "$tmp_file_path" "$file_path"
	if $created; then
		log "  -> wrote ${#video_data[@]}"
		log "  -> created $album_filename"
	else
		log "  -> wrote ${#video_data[@]}"
		log "  -> edited $album_filename"
	fi
}

handle_seed() {
	local -r SEED="$DATA_DIR/Seed.rec"
	log "seed file $SEED"

	# artist;playlist;title
	local urls
	local artist
	declare -a urls

	local current_epoch
	current_epoch=$(date +'%s')

	local amount=0
	while IFS= read -r line || [[ -n "$line" ]]; do
		if [[ -z "$line" ]]; then
			artist=""
			continue
		elif [[ "$line" == Artist:* ]]; then
			artist="${line#Artist: }"
			continue
		fi

		[[ -n $artist ]] || assert_fail "seed file is malformed: Artist in the wrong order, must be first"

		if [[ "$line" == Playlist:* ]] || [[ "$line" == PlaylistRefresh:* ]] || [[ "$line" == PlaylistUploads:* ]]; then
			local line_kind playlist
			IFS=": " read -r line_kind playlist <<< "$line"
			
			log "(seed \"$artist\") $playlist"

			local title
			title=$(playlist_extract_title "$playlist")

			local metadata="mutable"

			# normal Playlist (either release OLAK or otherwise)
			if [[ "$line_kind" == "Playlist" ]]; then
				metadata="immutable"
			fi

			# add prefix to upload playlists, otherwise treat like a refresh
			if [[ "$line_kind" == "PlaylistUploads" ]]; then
				title="Uploads - $title"
			fi

			# (artist, playlist, title)
			urls=( "${urls[@]}" "$metadata;$artist;$playlist;$title" )
		fi

		if [[ "$line" == Releases:* ]]; then
			playlist_list="${line#Releases: }"
			log "(seed list \"$artist\") $playlist_list"
		
			output=$(handle_seed_playlist_list "$artist" "$playlist_list")
			mapfile -t output_list <<< "$output"
			urls=( "${urls[@]}" "${output_list[@]}" )
		fi

		#((amount++)) - with `set -e` this entire thing dies as amount=0
		amount=$((amount + 1))
	done < <(recsel -e "Epoch < $current_epoch - $RECHECK_INTERVAL" -p Artist,Releases,Playlist,PlaylistRefresh,PlaylistUploads "$SEED")

	local tuple
	for tuple in "${urls[@]}"; do
		handle_seed_playlist "$tuple"
	done

	if [[ $amount -gt 0 ]]; then
		log "updated $amount entries (new epoch: $current_epoch)"

		# mark that we made changes
		recset -e "Epoch < $current_epoch - $RECHECK_INTERVAL" \
			-f Epoch -S "$current_epoch" \
			"$SEED"

		# TODO: bug-recutils: Recset does not respect comment formatting
		sed -i '/^#/s/\([^[:space:]]\)#/\1\n#/g' "$SEED"
	fi
}

# certain exports are needed for parallel
export -f path_store_sharded_nr
export SCRIPT_DIR DATA_DIR DLM
parallel_download_track() {
	# prelude (traces and error tracking)
	source "$SCRIPT_DIR/lib/prelude.sh"
	
	local mutability albumtitle albumartist trackindex title video_id
	IFS=$DLM read -r mutability albumtitle albumartist trackindex title video_id <<< "$1"

	# this is supposed to be a single atomic operation that might either succeed or
	# fail, which is why downloading is done by the ID boundary and not a playlist

	local final_output_path # theses paths are sharded by the first character
	path_store_sharded_nr final_output_path "$video_id" ".mp3"
	
	local exists=false
	if [[ -f "$final_output_path" ]]; then exists=true; fi

	if $exists && [[ "$mutability" == "immutable" ]]; then
		return
	fi

	# don't touch a single subshell here (no mktmp -d)
	# https://nullprogram.com/blog/2018/12/25/ for $RANDOM
	printf -v tmp_dir "/tmp/work_%s_%s_%s" "$$" "$PARALLEL_SEQ" "$RANDOM"
	mkdir "$tmp_dir"
	trap 'rm -rf "$tmp_dir"' EXIT

	local processed_file="${tmp_dir}/processed.mp3"
	local music_url="https://www.youtube.com/watch?v=${video_id}"

	if $exists && [[ "$mutability" == "mutable" ]]; then
		# metadata might have changed, lets reapply it
		cp "$final_output_path" "$processed_file"
	elif ! $exists; then
		local downloaded_file="${tmp_dir}/download.mp3"
		
		yt-dlp \
			-f bestaudio -t mp3 --audio-quality 0 \
			--no-warnings \
			--embed-metadata --embed-thumbnail --convert-thumbnails jpg \
			--continue \
			--cookies "$DATA_DIR/cookies.txt" \
			-o "$downloaded_file" \
			"$music_url" > /dev/null

		if [[ ! -f "$downloaded_file" ]]; then
			log "WARN yt-dlp failed to download ${video_id}"
			return 1 # signal to parallel
		fi

		# iPod Classic (Rockbox)

		# extract coverart into location (thanks for yt-dlp for extracting it nicely)
		local tmp_img="${tmp_dir}/coverart.jpg"
		ffmpeg -v error -i "$downloaded_file" -an -vcodec copy -f image2pipe - | \
		convert - -resize "320x320^" -gravity center -extent 320x320 \
				-strip -colorspace sRGB -type TrueColor -interlace none \
				-sampling-factor 2x2,1x1,1x1 -quality 85 "$tmp_img"

		ffmpeg -v error -i "$downloaded_file" -map 0:a -c:a copy -map_metadata 0 -id3v2_version 3 -y "$processed_file"
		eyeD3 --quiet --add-image "$tmp_img:FRONT_COVER" "$processed_file" > /dev/null 2>&1
	fi

	eyeD3 --quiet \
		--album="$albumtitle" \
		--album-artist="$albumartist" \
		--title="$title" \
		--track="$trackindex" \
		"$processed_file" > /dev/null 2>&1
	
	# atomic is a misnomer, really we just want to support ctrl-Cing the script at will
	# mv isn't atomic over different filesystems anyway
	mv "$processed_file" "$final_output_path"

	local cr_kind
	if $exists; then cr_kind="edited"; else cr_kind="downloaded"; fi

	local log_msg
	printf -v log_msg "%-10s %-11s %-20s %02d %s" \
		"$cr_kind" \
		"$video_id" \
		"${albumartist:0:20}" \
		"${trackindex#0}" \
		"$title"
	
	log "$log_msg"
}
export -f parallel_download_track

handle_missing() {
	# writes to collected_tracks_list (global)
	collect_tracks
	log "${#collected_tracks_list[@]} collected tracks"

	path_store_shards_youtube_id
	log "downloading missing JOBS=$JOBS"
	parallel \
		--jobs "$JOBS" \
		--line-buffer \
		parallel_download_track {} ::: "${collected_tracks_list[@]}"
}

main() {
	if [[ ! -d "$DATA_DIR" ]]; then
		assert_fail "the data directory $DATA_DIR is not a folder or does not exist"
	fi
	if ! command -v yt-dlp &> /dev/null; then
		assert_fail "'yt-dlp' could not be found. please install it"
	fi
	if ! command -v ffmpeg &> /dev/null; then
		assert_fail "'ffmpeg' could not be found. please install it"
	fi
	if ! command -v parallel &> /dev/null; then
		assert_fail "'parallel' could not be found. please install it"
	fi
	if ! command -v rg &> /dev/null; then
		assert_fail "'rg' (ripgrep) could not be found. please install it"
	fi
	if ! command -v convert &> /dev/null; then
		assert_fail "'imagemagick' (convert) could not be found. please install it"
	fi
	if ! command -v eyeD3 &> /dev/null; then
		assert_fail "'eyeD3' could not be found. please install it"
	fi

	handle_seed
	handle_missing
}

main

#for line in "${collected_tracks_list[@]}"; do
#	IFS=$DLM read -r mutability albumtitle albumartist trackindex title youtubeid <<< "$line"
#	echo $mutability $albumtitle $albumartist $trackindex $title $youtubeid
#done
