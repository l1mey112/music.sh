#!/usr/bin/env bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
readonly SCRIPT_DIR

# NOTE: do not use readonly in functions, these create global variables
readonly SECONDS_MINUTE=60
readonly SECONDS_HOUR=$((60 * SECONDS_MINUTE))

# PARAMETERS {{

readonly JOBS=${JOBS:-4}
readonly DATA_DIR=${DATA_DIR:-"$SCRIPT_DIR/music"}

# TODO: add a fuzz factor as well
readonly RECHECK_INTERVAL=${RECHECK_INTERVAL:-$((1 * SECONDS_HOUR))}

# }}

source "$SCRIPT_DIR/lib/prelude.sh"
source "$SCRIPT_DIR/lib/path.sh"

# playlist_extract_canonical
#
# This is needed for various reasons. When you go to the Releases tab of
# some artist on their YouTube channel, for example
#  
#     https://www.youtube.com/@lapix_official/releases
#
# it will contain playlists with prefix OLAK5uy, these are albums.
# (see ^[archiveteam] for a proper taxonomy)
#
# Take this album ^[1] for example. Most of the songs there are YouTube
# Music "square videos" which are autogenerated and contain the metadata
# in the description in a predictable format that yt-dlp scrapes.
#
# There are some videos in here, for example "Concept Of Reality feat. Renko"
# which aren't autogenerated and hence doesn't have correct metadata in the
# description. The reason why is because this isn't the right playlist. If
# you take the playlist url and replace "www." with "music." you will be
# redirected to a playlist with an ID with a different playlist.
#
# This playlist contains videos that are only autogenerated, and hence have
# the right description. See ^[2] on the yt-dlp Discord for the full convo.
#
# [^archiveteam]: https://wiki.archiveteam.org/index.php/YouTube/Technical_details
# [^1]: https://www.youtube.com/playlist?list=OLAK5uy_mWid7P-a7WtzrJmkmoTewY6Vy2R23jkrA
# [^2]: https://discord.com/channels/807245652072857610/807245652072857613/1467002380301373746
#
# TLDR: use this to get the right playlist.
#
playlist_extract_canonical() {
	local -r URL="$1"
	local -r useragent="Mozilla/5.0 (X11; Linux x86_64; rv:147.0) Gecko/20100101 Firefox/147.0"

	local playlist
	playlist=$(echo "$URL" | sed -E 's/(www\.)?youtube\.com/music.youtube.com/')

	# <link rel="canonical" href="https://music.youtube.com/playlist?list=NEW_URL">
	local extracted
	extracted=$(curl -sL "$playlist" -A "$useragent" | grep -oP '<link rel="canonical" href="\K[^"]+')

	if [[ -z "$extracted" ]] || [[ "$extracted" == "undefined" ]] || [[ "$extracted" != http* ]]; then
		log "playlist_extract_canonical: returned empty, you might be using playlist lists wrong"
		log "playlist_extract_canonical: url: $URL"
		echo "$URL"
	else
		# echo "$extracted" | sed 's/music\.//'
		echo "${extracted/music./}"
	fi
}

# does not call path_safe on the name, caller's responsibility
playlist_extract_title() {
	local -r URL="$1"

	local output
	output=$(yt-dlp "$URL" --flat-playlist --dump-single-json | jq -r .title)

	local ytdlp_status=$?
	[[ $ytdlp_status -eq 0 ]] || assert "  -> yt-dlp failed for this seed file (exit code: $ytdlp_status)"

	echo "$output"
}

recutils_to_json() {
	# https://lists.gnu.org/archive/html/help-recutils/2014-06/msg00001.html
	
	# shouldn't have serialisation issues
	rec2csv -t "$1" "$2" | python3 -c 'import csv,json,sys; print(json.dumps(list(csv.DictReader(sys.stdin))))'
}

recutils_to_json_single() {
	recutils_to_json "$1" "$2" | jq '.[0]'
}

# array of '[{ ... }, 0, { ... }]' which is (AlbumDescriptor, tracknumber, Track) pairs
declare -a collected_tracks_list=()

collect_tracks_file() {
	local album_descriptor tracks

	album_descriptor=$(recutils_to_json_single AlbumDescriptor "$1")
	tracks=$(recutils_to_json Track "$1")

	local tracknumber=1
	while read -r track; do
		collected_tracks_list+=("[$album_descriptor,$tracknumber,$track]")
		tracknumber=$((tracknumber + 1))
	done < <(jq -c '.[]' <<< "$tracks")
}

# TODO: it is very important that this supports local files as well, support for
#       that will come when the schema is changed

collect_tracks() {
	# for every file inside $DATA_DIR that contains an AlbumDescriptor visit
	# that file and handle the Tracks
	local pattern="%rec: AlbumDescriptor _Schema/AlbumDescriptor.rec"
	local file_path

	while IFS= read -r -d '' file_path; do
		collect_tracks_file "$file_path"
	done < <(find "$DATA_DIR" -type f -exec grep -lZ -F "$pattern" {} +)
}

handle_seed_playlist_list() {
	local -r ARTIST="$1"
	local -r PLAYLIST_LIST_URL="$2"

	local output
	output=$(yt-dlp --flat-playlist --print "%(webpage_url)s;%(title)s" "$PLAYLIST_LIST_URL" 2>/dev/null)

	local ytdlp_status=$?
	[[ $ytdlp_status -eq 0 ]] || assert "  -> yt-dlp failed for this seed file (exit code: $ytdlp_status)"

	if [[ -z "$output" ]]; then
		log "  -> no playlists discovered"
		return
	fi

	local playlist_data
	mapfile -t playlist_data <<< "$output"
	for line in "${playlist_data[@]}"; do
		local playlist_url playlist_title
		IFS=';' read -r playlist_url playlist_title <<< "$line"

		playlist_url=$(playlist_extract_canonical "$playlist_url")

		# (kind, artist, playlist, title)
		echo "immutable;$ARTIST;$playlist_url;$playlist_title"
	done

	log "  -> got ${#playlist_data[@]} playlists"
}

# accepts a tuple of the form "kind;artist;playlist;title"
handle_seed_playlist() {
	# kind;artist;playlist;title
	local kind artist playlist title
	IFS=';' read -r kind artist playlist title <<< "$1"

	log "Writing: $artist - $title ($kind)"

	local album_filename
	local artist_path

	album_filename="$(path_safe "$title").rec"
	artist_path="$DATA_DIR/$(path_safe "$artist")"
	mkdir -p "$artist_path"

	local tmp_dir file_path tmp_file_path
	tmp_dir=$(mktemp -d)
	# need to remove the trap when coming out, for some reason
	trap 'rm -rf -- "$tmp_dir"; trap - RETURN' RETURN

	# TODO: at some point, it might be preferrable to actually search through
	#       all the files in the "$artist_path" directory to find a file with
	#       a matching Source, then do the update.
	#
	#       until then if you change the name of the file and reseed, it will
	#       duplicate the album. probably not what you want, but in the current
	#       state you do get to change the name anyway.
	#
	#       if the name of the playlist changes, this also will happen.

	# we want to atomically edit this playlist nicely
	tmp_file_path="$tmp_dir/album.rec"
	file_path="$artist_path/$album_filename"
	local created=false

	# if the file doesn't exist, create it
	if ! [[ -e "$file_path" ]]; then
		created=true
		cat <<EOF > "$tmp_file_path"
%rec: AlbumDescriptor _Schema/AlbumDescriptor.rec

AlbumArtist: $artist
AlbumTitle: $title
Source: $playlist
Created: $(LC_ALL=C TZ=UTC0 date)
Metadata: $kind

# automatically generated, do not edit tracklist below

%rec: Track _Schema/Track.rec
EOF
	else
		# --force this because we are deleting all the entries (dangerous)
		cp "$file_path" "$tmp_file_path"
		recdel -t Track --force "$tmp_file_path"
	fi

	local video_data
	mapfile -t video_data < <(yt-dlp \
		--match-filter "original_url!*=/shorts/ & url!*=/shorts/" \
		--flat-playlist --print "%(id)s;%(title)s" "$playlist" 2>/dev/null)

	for line in "${video_data[@]}"; do
		local video_id video_title
		IFS=';' read -r video_id video_title <<< "$line"

		# we want to --force this because we can't access the schema anyway
		recins -t Track --force "$tmp_file_path" \
			-f Title -v "$video_title" \
			-f YouTubeId -v "$video_id"
	done

	# atomic please
	mv "$tmp_file_path" "$file_path"
	if $created; then
		log "  -> wrote ${#video_data[@]}"
		log "  -> created $album_filename"
	else
		log "  -> wrote ${#video_data[@]}"
		log "  -> edited $album_filename"
	fi
}

handle_seed() {
	local -r SEED="$DATA_DIR/Seed.rec"
	log "seed file $SEED"

	# artist;playlist;title
	local urls
	local artist
	declare -a urls

	local current_epoch
	current_epoch=$(date +'%s')

	local amount=0
	while IFS= read -r line || [[ -n "$line" ]]; do
		if [[ -z "$line" ]]; then
			artist=""
			continue
		elif [[ "$line" == Artist:* ]]; then
			artist="${line#Artist: }"
			continue
		fi

		[[ -n $artist ]] || assert "seed file is malformed: Artist in the wrong order, must be first"

		if [[ "$line" == PlaylistRefresh:* ]] || [[ "$line" == PlaylistUploads:* ]]; then
			local line_kind playlist
			IFS=": " read -r line_kind playlist <<< "$line"
			
			log "(seed \"$artist\") $playlist"

			local title
			title=$(playlist_extract_title "$playlist")

			# add prefix to upload playlists, otherwise treat like a refresh
			if [[ "$line_kind" == "PlaylistUploads" ]]; then
				title="Uploads - $title"
			fi

			# (artist, playlist, title)
			urls=( "${urls[@]}" "mutable;$artist;$playlist;$title" )
		fi

		if [[ "$line" == Playlists:* ]]; then
			playlist_list="${line#Playlists: }"
			log "(seed list \"$artist\") $playlist_list"
		
			output=$(handle_seed_playlist_list "$artist" "$playlist_list")
			mapfile -t output_list <<< "$output"
			urls=( "${urls[@]}" "${output_list[@]}" )
		fi

		#((amount++)) - with `set -e` this entire thing dies as amount=0
		amount=$((amount + 1))
	done < <(recsel -e "Epoch < $current_epoch - $RECHECK_INTERVAL" -p Artist,Playlist,PlaylistRefresh,PlaylistUploads "$SEED")

	for tuple in "${urls[@]}"; do
		handle_seed_playlist "$tuple"
	done

	if [[ $amount -gt 0 ]]; then
		log "updated $amount entries (new epoch: $current_epoch)"

		# mark that we made changes
		recset -e "Epoch < $current_epoch - $RECHECK_INTERVAL" \
			-f Epoch -S "$current_epoch" \
			"$SEED"
	fi
}

handle_seed
collect_tracks # writes to collected_tracks_list (global)

echo "${#collected_tracks_list[@]}"

for line in "${collected_tracks_list[@]}"; do
	echo "$line"
done
